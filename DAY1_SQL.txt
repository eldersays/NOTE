事务的ACID:
1.Atom 原子性 事务为操作的最小单元, 事务内所有操作要么全部成功, 要么全部失败
2.Contist 一致性, 个人理解一致性是原子性和隔离性的目的, 达到业务层数据约束的一致性
3. isolate 隔离性 事务在最终提交前, 中间过程的数据对其他事务是不可见的
4. during 持久性 一旦事务提交 数据则永久保存在数据库中


如果所有事务串行执行 则只需要满足原子性就能满足隔离性与一致性

事务并行时可能的问题:
	1. 丢失修改: 事务A和事务B同时对某一数据修改, A先提交, B提交后覆盖了A的数据
	2. 不可重复读: 事务B 读取X, 事务A对数据X修改, 事务B这时候再次读取X, 前后两次数据不一致
	3. 脏读: 事务A对数据X修改, 事务B读取X, 事务A撤销的这一次更改, 事务B读取的数据为脏数据
	4. 幻读: 事务B按某条件过滤数据, 事务A插入/删除了这一范围内的某些数据, 事务B再次读取, 两次读取数据量不一致


锁机制:
	锁粒度:
		1. 行锁
		2. 表锁
		
	锁分类:
		X锁	修改锁
		S锁 共享锁
		数据加上X锁后不能加其他任何锁, 数据加上S锁后能其他事务能加上S锁, 但不能加X锁
		
		意向锁:
		IX
		IS
		如果需要对表进行加锁, 需要逐行检测每一行的锁,性能较低, 因此引出意向锁, 事务A获取了表X中数据的M数据的X锁,同时获取了表X的IX锁, 其他事务能获取到表的IX, IS锁,但不能获取到表的X锁

两段锁协议:
① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。
② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。
即事务的执行分为两个阶段：
第一阶段是获得封锁的阶段，称为扩展阶段。
第二阶段是释放封锁的阶段，称为收缩阶段。
若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。


MySQL 隐式与显示锁定
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;


隔离级别
未提交读（READ UNCOMMITTED）
事务中的修改，即使没有提交，对其它事务也是可见的。

提交读（READ COMMITTED）
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可重复读（REPEATABLE READ）
保证在同一个事务中多次读取同样数据的结果是一样的。

可串行化（SERIALIZABLE）
强制事务串行执行。
需要加锁实现，而其它隔离级别通常不需要。
隔离级别	脏读	不可重复读	幻影读
未提交读	√	√	√
提交读	×	√	√
可重复读	×	×	√
可串行化	×	×	×


多版本并发控制
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。



关系数据库设计理论
函数依赖
记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

数据库三大范式
高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。
1. 第一范式 (1NF)
属性不可分。

2. 第二范式 (2NF)
每个非主属性完全函数依赖于键码。

可以通过分解来满足。

3. 第三范式 (3NF)
非主属性不传递函数依赖于键码。









